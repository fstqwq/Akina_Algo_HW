\documentclass[11pt,a4paper,oneside]{article}

\usepackage{euler,amsthm,amsmath,amsfonts,graphicx,epigraph,indentfirst,enumerate,comment,listings,fontspec,color,subcaption,listings}
\usepackage{xeCJK}
\usepackage{hw}
\usepackage{pythonhighlight}

\renewcommand{\hwtitle} {CS217 Homework 2}	
\renewcommand{\hwauthor}{Akina}
\renewcommand{\hwdate}{\today}

\begin{document}
\title{\hwtitle}
\author{\hwauthor}
\date{\hwdate}
\maketitle

\section*{Sorting Algorithms}
\begin{problem}{1}
	\statement
	Given an array $A$ of $n$ items (numbers), we can find the maximum with $n-1$ comparisons (this is simple).
	Show that this is optimal: that is, any algorithm that does $n-2$ or fewer comparisons will fail to find the maximum 
	on some inputs.
	\solution
	\begin{proof}
		Consider all elements as vertices and comparisons as directed edges from larger to smaller ones, or two elements are identical. Then consider how we conclude the maximum element: there's a path from the maximum element to every other element -- it's continuous inequations that mathmatically proved the maximality.
		The simple algorithm forms a tree finally. Everytime it compare the current root and next element, and draw an edge between them and decide the new root.

		If there are $n - 2$ or few edges in the graph, the graph must not be connected since an edge can only decrease the number of connected components by 1, but at beginning we have $n$ components. Thus there are at least two components, which we don't really know their relations at all -- we can not conclude such inequation between any two vertex in different components, as well as maximum element.
	\end{proof}
\end{problem}

\begin{problem}{2}
	\statement
	Let $A$ be an array of size $n$, where $n$ is even. 
	Describe how to find both the minimum and the maximum
	with at most $\frac{3}{2} n  - 2$ comparisons.
	Make sure your solution is {\em simple}, in describe it 
	in a clear and succinct way!

	\solution
	Life is short, I choose python.
\begin{python}
def min_max(a, n):
    small = []
    large = []
    for i in range(0, n, 2):
        res = a[i] > a[i + 1]
        small.append(a[i + res])
        large.append(a[i + 1 - res])
    return (min(small), max(large))
\end{python}
	First part, we make pair of every two ajancent number and dividing them by the comparison result taking $\frac n 2$ comparisons.
	Second part we decide maximum and minimum seperately, and both takes $\frac n 2 - 1$ comparisons. In total, $\frac {3} {2} n - 2$ comparisons achieved.
\end{problem}
\begin{problem}{3}
	\statement
	Given an array $A$ of size $n = 2^k$, find the second largest element element
	with at most $n + \log_2(n)$ comparisons. 
	Again, your solution should be {\em simple}, and you should explain
	it in a clear and succinct way!
	
	\solution
	Life is even shorter, I choose python again.
\begin{python}
def second_max(a, n):
    b = [0] * (n + 1) + a
    for i in range(n - 1, 0, -1):
        b[i] = max(b[i * 2], b[i * 2 + 1])
    c = []
    x = 1
    while x < n:
        x *= 2
        x ^= b[x] != b[x >> 1]
        c.append(b[x ^ 1])
    return max(c)
\end{python}
	First part we do $n - 1$ comparisons to get the maximum element by a heap-like order, using an array of $2n$ element to store the "comparison tree". In my implementation, to use $1$-indexed array there's an auxiliary number taking the place of $0$.

	Now get back and see how the maximum is elected: every root of subtree is the maximum of corresponding leaves, and the root of the whole tree killed the maximum of some other parts on the path it became a king, where the union of those parts is the union of all other leaves. Second maximum is exactly the maximum of all other leaves, so just visit the path once and we can conclude the second maximum by $\log_2(n)$ comparisons.

	In total, $n + \log_2(n) - 1$ comparisons achieved.
\end{problem}


\end{document}
